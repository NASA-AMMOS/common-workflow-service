name: CI Base

on:
  push:
    branches: [main, ci_docker] # Adjust branches as needed
  pull_request:
    branches: [main] # Adjust branches as needed

permissions:
  contents: read
  packages: write # Needed to push images to GHCR

jobs:
  build-push-run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract CWS Version and Define Image Tag
        id: image_info
        run: |
          # Assuming utils.sh is at the repository root
          CWS_VER=$(grep 'export CWS_VER=' utils.sh | cut -d"'" -f2)
          # Use GitHub owner and repo name for GHCR image path (lowercase)
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_LOWER=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME="ghcr.io/$OWNER_LOWER/$REPO_LOWER"
          echo "version=$CWS_VER" >> $GITHUB_OUTPUT
          echo "original_tag=nasa-ammos/common-workflow-service:$CWS_VER" >> $GITHUB_OUTPUT
          echo "ghcr_tag=$IMAGE_NAME:$CWS_VER" >> $GITHUB_OUTPUT
        working-directory: ${{ github.workspace }} # Run from repo root

      - name: Build CWS Docker Image using script
        run: |
          chmod +x install/docker/cws-image/build.sh
          # The script builds using the 'nasa-ammos/...' tag internally
          ./install/docker/cws-image/build.sh
        working-directory: ${{ github.workspace }} # Run from repo root

      - name: Re-tag image for GHCR
        run: |
          echo "Tagging ${{ steps.image_info.outputs.original_tag }} as ${{ steps.image_info.outputs.ghcr_tag }}"
          docker tag "${{ steps.image_info.outputs.original_tag }}" "${{ steps.image_info.outputs.ghcr_tag }}"

      - name: Push Docker image to GHCR
        run: |
          echo "Pushing ${{ steps.image_info.outputs.ghcr_tag }}"
          docker push "${{ steps.image_info.outputs.ghcr_tag }}"

      - name: Prepare Docker Compose Environment
        run: |
          # Create dummy creds file required by docker-compose volume mount
          # Adjust if real creds needed via secrets in the future
          mkdir -p ~/.cws
          touch ~/.cws/creds
          chmod 700 ~/.cws/creds
          echo "Dummy creds file created at ~/.cws/creds"

          # Create external network required by docker-compose
          docker network create cws-network
          echo "Docker network 'cws-network' created"
        working-directory: install/docker/console-db-es-ls-kibana

      - name: Update image tag in docker-compose.yml
        run: |
          # Escape slashes in the image tag for sed
          ESCAPED_TAG=$(echo "${{ steps.image_info.outputs.ghcr_tag }}" | sed 's/\//\\\//g')
          echo "Updating image tag in docker-compose.yml to $ESCAPED_TAG"
          # Target both cws and cws-worker services
          sed -i "s/image: nasa-ammos\/common-workflow-service:.*/image: $ESCAPED_TAG/g" docker-compose.yml
          echo "docker-compose.yml after update:"
          cat docker-compose.yml
        working-directory: install/docker/console-db-es-ls-kibana

      - name: Start Services with Docker Compose
        run: docker-compose up -d
        working-directory: install/docker/console-db-es-ls-kibana

      - name: Verify CWS Console Startup
        run: |
          echo "Waiting up to 5 minutes for CWS console to become healthy..."
          MAX_WAIT=300 # 5 minutes max wait
          INTERVAL=15  # Check every 15 seconds
          ELAPSED=0
          # Use the healthcheck URL from docker-compose.yml
          HEALTHCHECK_URL="https://localhost:38443/cws-ui/login"

          while true; do
            # Use curl's exit code to check success (-k for self-signed cert, -f to fail on server errors, -s silent, -L follow redirects)
            if curl -kfsL --output /dev/null "$HEALTHCHECK_URL"; then
              echo "CWS console is up and responding at $HEALTHCHECK_URL!"
              echo "Current running containers:"
              docker ps
              exit 0
            fi

            if [ $ELAPSED -ge $MAX_WAIT ]; then
              echo "CWS console did not become healthy within $MAX_WAIT seconds."
              echo "Current running containers:"
              docker ps
              echo "Docker Compose logs:"
              docker-compose logs
              exit 1
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
            echo "Still waiting for CWS console... ($ELAPSED/$MAX_WAIT seconds)"
          done
        working-directory: install/docker/console-db-es-ls-kibana # Ensure correct context for docker-compose logs

      # Optional: Add cleanup step if needed
      # - name: Stop Services
      #   if: always() # Run even if previous steps fail
      #   run: docker-compose down
      #   working-directory: install/docker/console-db-es-ls-kibana
