-- Create indices that help with proc_inst_changed trigger performance
CREATE INDEX IF NOT EXISTS PARENT_ACT_INST_ID_ ON ACT_HI_ACTINST (PARENT_ACT_INST_ID_);
CREATE INDEX IF NOT EXISTS ACT_TYPE_ ON ACT_HI_ACTINST (ACT_TYPE_);

-- CWS PROCESS STATUS SUPPORT
CREATE TABLE IF NOT EXISTS cws_proc_inst_status (
  id SERIAL PRIMARY KEY,
  proc_inst_id VARCHAR(255) NOT NULL,
  super_proc_inst_id VARCHAR(255),
  proc_def_key VARCHAR(255) NOT NULL,
  business_key VARCHAR(255),
  status VARCHAR(45) NOT NULL,
  start_time TIMESTAMP NOT NULL,
  end_time TIMESTAMP
);

CREATE INDEX IF NOT EXISTS IDX_PROC_INST_ID ON cws_proc_inst_status (proc_inst_id);
CREATE INDEX IF NOT EXISTS IDX_STATUS ON cws_proc_inst_status (status);
CREATE INDEX IF NOT EXISTS IDX_PROC_DEF_KEY_STATUS ON cws_proc_inst_status (proc_def_key, status);
CREATE INDEX IF NOT EXISTS IDX_DATE_RANGE ON cws_proc_inst_status (proc_inst_id, start_time, end_time);
CREATE INDEX IF NOT EXISTS IDX_BUSINESS_KEY_STATUS ON cws_proc_inst_status (business_key, status);

-- Create status row when process instance is run
CREATE OR REPLACE FUNCTION new_proc_inst_func()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO cws_proc_inst_status (status, proc_inst_id, super_proc_inst_id, proc_def_key, business_key, start_time)
    VALUES ('running', NEW.PROC_INST_ID_, NEW.SUPER_PROCESS_INSTANCE_ID_, NEW.PROC_DEF_KEY_, NEW.BUSINESS_KEY_, NEW.START_TIME_);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER new_proc_inst
AFTER INSERT ON ACT_HI_PROCINST
FOR EACH ROW
EXECUTE FUNCTION new_proc_inst_func();

-- Delete status row when process instance is deleted
CREATE OR REPLACE FUNCTION proc_deleted_func()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM cws_proc_inst_status
    WHERE proc_inst_id = OLD.PROC_INST_ID_;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER proc_deleted
AFTER DELETE ON ACT_HI_PROCINST
FOR EACH ROW
EXECUTE FUNCTION proc_deleted_func();

-- Change status to 'incident' when an incident occurs
CREATE OR REPLACE FUNCTION new_incident_func()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE cws_proc_inst_status
    SET status = 'incident'
    WHERE proc_inst_id = NEW.PROC_INST_ID_;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER new_incident
AFTER INSERT ON ACT_RU_INCIDENT
FOR EACH ROW
EXECUTE FUNCTION new_incident_func();

-- Change status back to 'running' when an incident is deleted
CREATE OR REPLACE FUNCTION incident_resolved_func()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE cws_proc_inst_status
    SET status = 'running'
    WHERE proc_inst_id = OLD.PROC_INST_ID_;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER incident_resolved
AFTER DELETE ON ACT_RU_INCIDENT
FOR EACH ROW
EXECUTE FUNCTION incident_resolved_func();

-- When a process instance is finished, mark it as failed / completed
CREATE OR REPLACE FUNCTION proc_inst_changed_func()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.END_TIME_ IS NOT NULL THEN
        UPDATE cws_proc_inst_status
        SET status =
            CASE WHEN EXISTS (
                SELECT 1
                FROM ACT_HI_PROCINST PI
                LEFT JOIN ACT_HI_ACTINST AI ON PI.PROC_INST_ID_ = AI.PARENT_ACT_INST_ID_
                WHERE PI.END_TIME_ IS NOT NULL 
                  AND AI.ACT_TYPE_ IN ('noneEndEvent', 'endEvent', 'escalationEndEvent', 'compensationEndEvent', 'signalEndEvent', 'terminateEndEvent')
                  AND PI.PROC_INST_ID_ = NEW.PROC_INST_ID_
            )
            THEN 'complete'
            ELSE 'fail'
            END,
            end_time = NEW.END_TIME_
        WHERE proc_inst_id = NEW.PROC_INST_ID_;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER proc_inst_changed
AFTER UPDATE ON ACT_HI_PROCINST
FOR EACH ROW
EXECUTE FUNCTION proc_inst_changed_func();
